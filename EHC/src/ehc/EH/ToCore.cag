%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Is main body 'main'?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen).mainUseExists
SEM AGItf
  | AGItf       loc         .   mainUseExists
                                            =   case acoreExprMbVar @expr.letCBody of
                                                  Just n | n == hsnMain -> True
                                                  _                     -> False
                            .   insertMainUse
                                            =   not @mainUseExists
%%]

%%[(50 codegen)
SEM AGItf
  | AGItf       loc         .   insertMainUse
                                            :=  not @mainUseExists && @lhs.isMainMod
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Does a binding for main exist?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen).mainDefExists
SEM AGItf
  | AGItf       loc         .   mainDefExists
                                            =   let ds = [ b | (_,g) <- @expr.letValCBindL, b <- g, cbindNm b == hsnMain ]
                                                in  not (null ds)
                            .   insertMainDef
                                            =   not @mainDefExists
%%]

%%[(50 codegen)
SEM AGItf
  | AGItf       loc         .   insertMainDef
                                            :=  not @mainDefExists && @lhs.isMainMod
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Generation of core
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AGItf [ | | cmodule: CModule ]

SEM AGItf
  | AGItf       lhs         .   cmodule     =   let b = if @insertMainUse then acoreVar hsnMain else @expr.letCBody
                                                    d = if @insertMainDef then acoreLet CBindCateg_Plain [acoreBind1Ty hsnMain (acoreTyErr $ "EH.ToCore.AGItf.main") @expr.letCBody] else id
                                                in  CModule_Mod @lhs.moduleNm
                                                        [] -- imports are filled in later
                                                        [ CDeclMeta_Data tn
                                                            [ CDataCon_Con cn (ctagTag ctag) (ctagArity ctag)
                                                            | (cn,dti) <- Map.toList $ dgiConstrTagMp dgi
                                                            , let ctag = dtiCTag dti
                                                            ]
                                                        | (tn,dgi) <- gamToAssocL @expr.gathDataGam
                                                        , not (dgiIsNewtype dgi)
                                                        ]
                                                        (
%%[[9
                                                           cSubstAppExpr True @expr.cSubst
%%]]
                                                           (foldr (\(c,b) e -> acoreLet c b e)
                                                             (d b)
                                                             (@expr.letTyCBindL ++ @extraCBindL ++ @expr.frontCBindL ++ @expr.letValCBindL
%%[[90
                                                             ++ @expr.backCBindL
%%]]
                                                             )
                                                           )
%%[[9
                                                           Nothing
%%]]
                                                        )
                                                        -- [ (tn,Map.toList m) | (tn,dgi) <- gamToAssocL @expr.gathDataGam, not (dgiIsNewtype dgi), let m = Map.map dtiCTag $ dgiConstrTagMp dgi ]
                loc         .   extraCBindL =   []
%%]

%%[(9 codegen)
SEM AGItf
  | AGItf       loc         .   extraCBindL :=  [(CBindCateg_Rec,@chrScopeMainBindL)]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Uniq's for Expr
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
SEM Expr
  | IConst CConst SConst Var Con
    App AppImpred AppTop Rec TypeAs
    Lam Let
%%[[12
    AppImpl
    LamImpl
%%]]
%%[[97
    IIConst
%%]]
                loc         .   lUniq_cexpr :   UNIQUEREF gUniq
%%]

%%[(97 codegen)
SEM PatExpr
  | Expr        loc         .   lUniq_cexpr :   UNIQUEREF gUniq
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% CTy to be used by generation via AbstractCore
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
SEM Decl
  | * -
      TySig
      Data
      KiSig
%%[[9
      Class Instance InstanceIntro Default
%%]]
%%[[11
      Type
%%]]
%%[[90
      FFE
%%]]
%%[[92
      GenerRep
%%]]
%%[[93
      FusionConv FusionDecl
%%]]
                loc         .   acorety     =   mkCTy @lhs.opts @finalTyExpanded @sysfty

SEM DataFieldExpr
  | Upd
                loc         .   acorety     =   mkCTy @lhs.opts @finalTyExprExpanded @sysfty

SEM Expr
  | Case
                loc         .   acorety     =   mkCTy @lhs.opts @finalTyExprExpanded @sysfty
  | Lam
%%[[12
    LamImpl
%%]]
                loc         .   acoretyArg  =   mkCTy @lhs.opts @finalTyArgExpanded @sysftyLamArg

SEM PatExpr
  | IConst CConst SConst Var Con AppTop Rec DataFields Irrefutable 
                loc         .   acorety     =   mkCTy @lhs.opts @finalTyExpanded @sysfty
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Expr
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

-- generated from ruler rules into EHRulerRules
  | IConst      loc         .   cexpr       =   acoreInt @lhs.opts @int
  | CConst      loc         .   cexpr       =   CExpr_Char @char
  | Var         loc         .   cexpr       =   acoreVar  @nm
  | Con         loc         .   cexpr       =   acoreVar  @nm
%%[(8 codegen)
ATTR Expr [ | | cexpr: CExpr ]

SEM Expr
  | Ann         loc         .   cexpr       =   @expr.cexpr
  | Let         loc         .   frontCBindL =   [(if True {- ehcOptPriv @lhs.opts -} then CBindCateg_Plain else CBindCateg_FFI,@decls.ffiCBindL)]
%%[[90
                            .   backCBindL  =   [(CBindCateg_FFE,@decls.ffeCBindL)]
%%]]
                            .   howToBind   =   if @isStrict then CBindCateg_Strict else CBindCateg_Rec
                            .   letTyCBindL =   [( CBindCateg_Rec
                                                 , @dataTyCBindL
                                                   ++ @decls.tyCBindL
                                                 )]
                            .   letValCBindL=   [( @howToBind
                                                 , @dataValCBindL
%%[[92
                                                   ++ @cDataGenerBindL
%%]]
                                                   ++ @decls.valCBindL
                                                 )]
                            .   letCBindOtherL
                                            =   []
                            .   mkBangEval  =   \e -> foldr ($) e @decls.bangEvalL
                            .   cexprtop    =   ehcOptTrace @lhs.opts "Expr.Let.lhs.cexprtop" $
                                                foldr (\(c,b) e -> acoreLet c b e)
                                                      (@mkBangEval @letCBody)
                                                      @letCBindRemL
  | App AppImpred
%%[[12
    AppImpl
%%]]
%%[[8
                loc         .   cexprapp
%%][9
                loc         .   (cexprapp,cexprappCSubst)
%%]]
                                            =   let mkapp f = wr $ acore1App f @arg.cexpr
%%[[(8 coresysf)
                                                    wr      = @sysfcTyArgLamWrap . @sysfcTyArgAppWrap
%%][8
                                                    wr      = id
%%]]
%%[[8
                                                    impl app= app @func.cexpr
%%][9
                                                    impl app= mkWeaveExpr @lhs.opts @lUniq_cexpr @lhs.finTyVarMp @arg.cSubst app @func.cexpr @appImplsCoeL []
%%]]
                                                in  impl mkapp
                loc         .   cexpr       =   if @func.isNewtype then @arg.cexpr else @cexprapp
  | Lam
%%[[12
    LamImpl
%%]]
%%[[8
                loc         .   cexpr
%%][9
                loc         .   (cexpr,cexprlamCSubst)
%%]]
                                            =   let 
%%[[(8 coresysf)
                                                    wr      = @sysfcTyArgLamWrap
%%][8
                                                    wr      = id
%%]]
%%[[8
                                                    lam     = acoreLam1Ty @arg.topNm @acoretyArg
                                                                (rceMatchTy @rceEnv [(@arg.topNm,@acoretyArg)] [RAlt_Alt [@arg.rpat] @body.cexpr @body.caseFailS])
%%][9
                                                    lam     = mkWeaveExpr @lhs.opts @lUniq_cexpr @lhs.finTyVarMp @body.cSubst wr @body.appFunCExpr @lamBodyCoeL @lamArgCoeL
%%]]
                                                in  lam
  | Case        loc         .   cexpr       =   let (ns,bs,as)
                                                      = if @isTupOfArg
                                                        then let ns = [ acbrefNm ref | (CExpr_Var ref) <- fuL2ExprL (reverse @expr.fuCExprL) ]
                                                             in  (zip ns (tyProdArgs @finalTyExprExpanded),[],@alts.raltL')
                                                        else let n = uidHNm @lUniq2
                                                             in  ([(n,@finalTyExprExpanded)],[acoreBind1Ty n @acorety @expr.cexpr],@alts.raltL)
                                                in  acoreLet CBindCateg_Plain bs (rceMatchTy @rceEnv (assocLMapElt (SysF.ty2TyC @lhs.opts @lhs.sysfEnv) ns) as)
  | AppTop      loc         .   cexprtop    =   @expr.cexpr
  | Rec         loc         .   cexprtop    =   @rcexpr
  | Parens TypeAs
                loc         .   cexpr       =   @expr.cexpr
  | AppTop Rec Let
%%[[8
                loc         .   cexpr
%%][9
                loc         .   (cexpr,cexprapptopCSubst)
%%]]
                                            =   let 
%%[[(8 coresysf)
                                                    wr      = @sysfcTyArgLamWrap
%%][8
                                                    wr      = id
%%]]
%%[[8
                                                    top     = @cexprtop
%%][9
                                                    top     = -- mkWeaveExpr @lhs.opts @lUniq_cexpr @lhs.finTyVarMp @body.cSubst wr @body.appFunCExpr @lamBodyCoeL @lamArgCoeL
                                                              mkWeaveExpr @lhs.opts @lUniq_cexpr @lhs.finTyVarMp @cSubstTop (wr . @cann) @cexprtop [] @lamArgCoeL
%%]]
                                                in  top
  | Undefined   loc         .   cexpr       =   acoreBuiltinUndefined @lhs.opts
  | CaseAltFail loc         .   cexpr       =   CExpr_CaseAltFail (CaseAltFailReason_Continue @caseId) (acoreBuiltinError @lhs.opts ("FAIL " ++ show @caseId))
%%]

-- generated from ruler rules into EHRulerRules
  | IConst      loc         .   cexprBase   :=  acoreInt @lhs.opts @int
  | CConst      loc         .   cexprBase   :=  CExpr_Char @char
  | Var         loc         .   cexprBase   :=  acoreVar @nm
  | Var IConst CConst
                loc         .   cexpr       :=  foAppCoe @lhs.opts @fo_ @lhs.finTyVarMp @lhs.cSubst @cexprBase
  | Con         loc         .   cexprBase   :=  acoreVar @nm
                            .   cexpr       :=  foAppCoe @lhs.opts @fo_ @lhs.finTyVarMp @lhs.cSubst @cexprBase

-- between variant 5 .. 99, reconstruction of AG rules, getting rid of ruler3 until Arie's ruler4 can be used
%%[(8 codegen noHmTyRuler)
SEM Expr
  | IConst      loc         .   cexprBase   =   acoreInt @lhs.opts @int
  | CConst      loc         .   cexprBase   =   CExpr_Char @char
  | SConst      loc         .   cexprBase   =   acoreBuiltinString @lhs.opts @str
%%[[97
  | IIConst     loc         .   cexprBase   =   acoreBuiltinInteger @lhs.opts @integer
%%]]
  | Var Con     loc         .   cexprBase   =   acoreExprUnThunk $ acoreVar @nm
%%]

%%[(8 codegen noHmTyRuler)
SEM Expr
  | IConst CConst SConst Var Con
%%[[97
    IIConst
%%]]
%%[[8
                loc         .   cexpr       =   @cexprBase
%%][9
                loc         .   (cexpr,cexprCSubst)
                                            =   foAppLRCoeAsSubst @lhs.opts @lUniq_cexpr @fo_ @lhs.finTyVarMp @lhs.cSubst $
%%[[(8 coresysf)
                                                @sysfcTyArgLamWrap $ @sysfcTyArgAppWrap $
%%]]
                                                @cexprBase
                lhs         .   cSubst      =   cSubstApp @lhs.cSubst @cexprCSubst
%%]]
%%]

%%[(9 codegen) hs
mkWeaveExpr :: EHCOpts -> UID -> VarMp -> CSubst -> (CExpr->CExpr) -> CExpr -> [Coe] -> [Coe] -> (CExpr,CSubst)
mkWeaveExpr opts uniq finTyVarMp csubst postmk expr lCoeL rCoeL
  = (postmk e, s1 `cSubstApp` s2)
  where (_,u1,u2) = mkNewLevUID2 uniq
        (ww,s1)   = coeWipeWeaveAsSubst2 opts u1 finTyVarMp csubst lCoeL rCoeL
        (e ,s2)   = coeEvalOnAsSubst u2 ww expr
%%]

%%[(9 codegen)
SEM Expr
  | Let         loc         .   letCBindOtherL
                                            :=  [ (CBindCateg_Rec,@chrScopeBindL) ]
  | App AppImpred
%%[[12
    AppImpl
%%]]
                lhs         .   cSubst      =   cSubstApp @arg.cSubst @cexprappCSubst
  | Lam
%%[[12
    LamImpl
%%]]
                lhs         .   cSubst      =   cSubstApp @body.cSubst @cexprlamCSubst
  | AppTop      loc         .   cSubstTop   =   @expr.cSubst
  | Rec         loc         .   cSubstTop   =   @recExpr.cSubst
  | Let         loc         .   cSubstTop   =   @body.cSubst
  | AppTop      lhs         .   cSubst      =   cSubstApp @expr.cSubst @cexprapptopCSubst
  | Rec         lhs         .   cSubst      =   cSubstApp @recExpr.cSubst @cexprapptopCSubst
  | Let         lhs         .   cSubst      =   cSubstApp @body.cSubst @cexprapptopCSubst
  | TypeAs      loc         .   (cexpr,cexprtypeasCSubst)
                                            :=  let (_,u1,u2) = mkNewLevUID2 @lUniq_cexpr
                                                    (e1,s1)   = foAppLRCoeAsSubst @lhs.opts u1 @fo_fitDown @lhs.finTyVarMp @expr.cSubst @expr.cexpr
                                                    (e2,s2)   = foAppLRCoeAsSubst @lhs.opts u2 @fo_        @lhs.finTyVarMp @expr.cSubst e1
                                                in  (e2, s1 `cSubstApp` s2)
                lhs         .   cSubst      =   cSubstApp @expr.cSubst @cexprtypeasCSubst
%%]

%%[(10 codegen)
SEM Expr
  | DynVar      loc         .   cexpr       =   acoreBuiltinUndefined @lhs.opts
%%]

%%[(97 codegen)
SEM PatExpr
  | Expr        loc         .   cexprBaseEq =   acoreVar @eqFldNm
                            .   (cexpr,cexprpatCSubst)
                                            =   let (e,s) = foAppLRCoeAsSubst @lhs.opts @lUniq_cexpr @fo_ @lhs.finTyVarMp @expr.cSubst @cexprBaseEq
                                                in  (acoreApp e [@expr.cexpr], s)
                lhs         .   cSubst      =   cSubstApp @expr.cSubst @cexprpatCSubst
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Annotation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
SEM Expr
%%[[8
  | *           loc         .   cann        =   id
%%][97
  | AppTop      loc         .   cann        =   CExpr_Ann (CExprAnn_Ty @finalTyExpanded)
  | * - AppTop  loc         .   cann        =   id
%%]]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Row based records, construction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
SEM Expr
  | Rec         loc         .   rcexpr          =   
%%[[10  
                                                    if  not (@recExpr.isExtFromEmpty)
                                                    then  fuMkCExpr @lhs.opts @lUniq3 (reverse @recExpr.fuCExprL) @recExpr.recCExpr
                                                    else
%%]]                                                    
                                                          acoreTagTupTy CTagRec (acoreTyErr "Expr.Rec.rexpr") -- foldl acore1App (CExpr_Tup CTagRec)
                                                            $ fuL2ExprL $ rowCanonOrder $ @recExpr.fuCExprL
%%[[10
                loc         .   lUniq3          :   UNIQUEREF gUniq
%%]]
%%]

%%[(8 codegen)
ATTR RecExpr [ | | recCExpr: CExpr ]
ATTR RecExpr Expr [ | | fuCExprL: {FieldUpdateL CExpr} ]

SEM RecExpr
  | Empty       loc         .   recCExpr        =   acoreTagTupTy CTagRec (acoreTyErr "RecExpr.Empty.recCExpr") [] -- CExpr_Tup CTagRec
                lhs         .   fuCExprL        =   []
  | Expr        loc         .   recCExpr        =   @expr.cexpr
                lhs         .   fuCExprL        =   []
  | Ext         loc         .   rcexpr          =   CExpr_TupIns @recExpr.recCExpr CTagRec @nm @offset @expr.cexpr
  | Upd         loc         .   rcexpr          =   CExpr_TupUpd @recExpr.recCExpr CTagRec @nm @offset @expr.cexpr
  | Ext Upd     lhs         .   fuCExprL        =   if @knRecHasLab
                                                    then (@nm,(@rcexpr,Nothing)) : @recExpr.fuCExprL
                                                    else @recExpr.fuCExprL

SEM Expr
  | * - Rec     lhs         .   fuCExprL        =   []
%%]

%%[(8 codegen)
ATTR RecExpr [ | | isExtFromEmpty: Bool ]

SEM RecExpr
  | Empty       lhs         .   isExtFromEmpty  =   True
  | Expr        lhs         .   isExtFromEmpty  =   False
  | Upd         lhs         .   isExtFromEmpty  =   not @knRecHasLab && @recExpr.isExtFromEmpty
  | Ext         lhs         .   isExtFromEmpty  =   @recExpr.isExtFromEmpty
%%]

%%[(8 codegen)
SEM RecExpr
  | Ext Upd     loc         .   offset          =   acoreInt @lhs.opts (tyRecOffsetWithLkup (varmpTyLookupCyc2 @lhs.finTyVarMp) @nm @recExpr.ty)
%%]

%%[(10 codegen)
SEM RecExpr
  | Ext Upd     loc         .   offset          :=  cSubstApp @expr.cSubst $ acoreNmHolePred @prUid
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Data based records, construction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
SEM Expr
  | DataFields  loc         .   dfexpr      =   let mkTup dti mkDflt con
                                                      = foldl acore1App con
                                                        . fuL2ExprL
                                                        -- . (\v -> v `seq` tr "Expr.DataFields.dfexpr" ("arity" >#< length dflt) v)
                                                        . listSaturateWith 0 (ctagArity (dtiCTag dti) - 1) (\(_,(_,Just o)) -> o) dflt
                                                        -- . (\v -> v `seq` tr "Expr.DataFields.dfexpr2" ("arity" >#< length dflt) v)
                                                        . fuMap (\l mke -> let o = fldInt $ dtiOffsetOfFld l dti in (mke dti o,o))
                                                      where dflt = [ (o,(f,(CExpr_TupIns (acoreBuiltinUndefined @lhs.opts) (dtiCTag dti) f (acoreInt @lhs.opts o) (mkDflt f),Just o)))
                                                                   | (f,i) <- Map.toList $ dtiFldMp dti, let o = fldInt $ dfiOffset i
                                                                   ]
                                                in  if dgiIsNewtype @dgi
                                                    then acoreLet CBindCateg_Plain @dataFieldExpr.dfeCBindL
                                                         $ head $ fuL2ExprL $ fuMap (\_ f -> (f emptyDataTagInfo 0,0)) $ @dataFieldExpr.fuCExprL
                                                    else case @dataFieldExpr.mbConNm of
                                                           Just conNm
                                                             -> acoreLet CBindCateg_Plain @dataFieldExpr.dfeCBindL
                                                                  (mkTup (dgiDtiOfCon conNm @dgi) (const $ acoreBuiltinUndefined @lhs.opts) @dataFieldExpr.dfeCExpr @dataFieldExpr.fuCExprL)
                                                           _ -> acoreLet CBindCateg_Plain (err ++  @dataFieldExpr.dfeCBindL)
                                                                  (acoreSatSelsCasesTy (rceUpdEnv (acoreVar en) @rceEnv) (Just (mkHNm @lUniq,(acoreTyErr $ "EH.ToCore.Expr.DataFields: " ++ show (mkHNm @lUniq)))) @dataFieldExpr.dfeCExpr alts)
                                                             where alts = [ ( dtiCTag dti
                                                                            , [ (f,acoreTyErr $ "EH.Expr.DataFields.dfexpr: " ++ show f,{-f,-} fldInt $ dfiOffset i) | (f,i) <- Map.toList $ dtiFldMp dti ]
                                                                            , Nothing
                                                                            , mkTup dti acoreVar (CExpr_Tup $ dtiCTag dti) @dataFieldExpr.fuCExprL
                                                                            )
                                                                          | dti <- @dtiInFldL
                                                                          ]
                                                                   err = [acoreBind1Ty en (acoreTyErr $ "EH.ToCore.Expr.DataFields.en: " ++ show en) (acoreBuiltinError @lhs.opts ("has no field update '" ++ show @fldL ++ "'"))]
                                                                   en = mkHNm "_upd_error"
                            .   cexpr       =   @dfexpr
%%]

%%[(8 codegen)
ATTR
  DataFieldExpr
    [ | | dfeCExpr: CExpr
          dfeCBindL: CBindL
          fuCExprL: {FieldUpdateL (DataTagInfo -> Int -> CExpr)}
    ]

SEM DataFieldExpr
  | Upd         loc         .   fldExprNm   =   mkHNm @lUniq
                lhs         .   fuCExprL    =   let mke dti o = CExpr_TupIns @dataFieldExpr.dfeCExpr (dtiCTag dti) @nm (acoreInt @lhs.opts o) (acoreVar @fldExprNm)
                                                in  (@nm,(mke,Nothing)) : @dataFieldExpr.fuCExprL
                            .   dfeCBindL   =   acoreBind1Ty @fldExprNm @acorety @expr.cexpr : @dataFieldExpr.dfeCBindL
  | Con         lhs         .   dfeCExpr    =   CExpr_Tup (dtiCTag @dti)
                            .   fuCExprL    =   []
                            .   dfeCBindL   =   []
  | Expr        loc         .   dfeCExpr    =   @expr.cexpr
                            .   fuCExprL    =   []
                            .   dfeCBindL   =   []

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Row based records, dissection
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

20100729 AD: Selections are not working anymore, because labels have been removed from core

%%[(8 codegen)
SEM Expr
  | Sel         loc         .   offset          =   acoreInt @lhs.opts (tyRecOffsetWithLkup (varmpTyLookupCyc2 @lhs.finTyVarMp) @lbl @expr.ty)
                            .   cexpr           =   let  [n1,n2] = map uidHNm . mkNewUIDL 2 $ @lUniq_freshKnTy
                                                    -- in   mkCExprSelCase @rceEnv (Just n1) @expr.cexpr CTagRec n2 @lbl @offset Nothing
                                                    in   acoreSelCaseTy @rceEnv (Just (n1,(acoreTyErr $ "EH.ToCore.Expr.Sel.n1: " ++ show n1))) @expr.cexpr CTagRec n2 {- @lbl -} @offset Nothing
%%]
  | Sel         loc         .   offset          =   acoreInt @lhs.opts (tyRecOffset @lbl (@lhs.finTyVarMp `varUpd` @expr.ty))

%%[(10 codegen)
SEM Expr
  | Sel         loc         .   offset          :=  cSubstApp @expr.cSubst $ acoreNmHolePred @prUid
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Data constr wrapper
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
SEM DataConstr
  | Constr      lhs         .   valCBindL   =   [] -- mkDataConCBindL @lhs.opts @ctag @conNm @lhs.isNewtype
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Data field selector
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
SEM Decl
  | Data        loc         .   fldSelCBindL=   let (xn1:xn2:_) = hsnLclSupply
                                                    tgSels f i = [ (t,[(f,acoreTyErr $ "EH.ToCore.Decl.Data.tgSels:" ++ show f, {-f,-} fldInt o)],Nothing,acoreVar f) | (t,o) <- Map.toList $ dficInTagMp i ]
                                                    ty1 f = valGamLookupTyDefault f @lhs.finValGam
                                                    ty2 t = SysF.ty2TyC @lhs.opts @lhs.sysfEnv t
                                                in  if @isNewtype
                                                    then [ [ acoreBind1Ty f (ty2 $ ty1 f) (acoreVar $ ehcOptBuiltin @lhs.opts ehbnId)
                                                           | (f,i) <- Map.toList $ dgiFldInConstrMp @dgi
                                                         ] ]
                                                    else [ [ acoreBind1Ty f (ty2 t)
                                                               (acoreLamTy [(xn1,acoreTyErr "EH.ToCore.Decl.Data.")]
                                                                 (acoreSatSelsCasesTy (rceUpdEnv (acoreVar en) @rceEnv) (Just (xn2,ty2 $ appUnArrArg t)) (acoreVar xn1) tg))
                                                           ]
                                                           ++ (if isSaturated then [] else [ acoreBind1Ty en (acoreTyErr $ "EH.ToCore.Decl.Data.en: " ++ show en) (acoreBuiltinError @lhs.opts ("has no field selection '" ++ show f ++ "'")) ])
                                                         | (f,i) <- Map.toList $ dgiFldInConstrMp @dgi
                                                         , let en = hsnUniqifyStr HsNameUniqifier_New "datafield_sel_error" f -- hsnSuffix f "_datafield_sel_error"
                                                               tg = tgSels f i
                                                               isSaturated = length tg == Map.size (dgiConstrTagMp @dgi)
                                                               t = ty1 f
                                                         ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Data: all bindings
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Data: type bindings
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8888 codegen coresysf tycore)
SEM Decl
  | Data        loc         .   ctyData     =   let t = if @isNewtype
                                                        then snd (snd (tyRecExts2 @dataAltTy !! 0) !! 0)
                                                        else @dataAltTy
                                                in  C.tyToTyCore fitsInForToTyCore (tyKiGamLookupKi @lhs.finTyKiGam)
                                                    $ ((assocTyLToVarMp $ zipWith (\t n -> (tyVar t, appCon n)) @tyVars.tyL @tyVars.nmL) `varUpd`)
                                                    $ t
                lhs         .   tyBindL     =   let nms = @tyVars.nmL
                                                    (mk,_) = C.tcMergeLamTySeq1AndArgNms @cki nms
                                                in  [ C.mkTyBind1 @tyNm @cki (mk @ctyData)
                                                    ]
%%]

%%[(8 codegen)
SEM Decl
  | Data        lhs         .   valCBindL   =   concat @fldSelCBindL ++ @constrs.valCBindL
%%]

%%[(8 codegen coresysf) hs
-- | Make bindings for type (of datatype), given various bits of info
mkDataTyCBindL :: EHCOpts -> ToSysfEnv -> (Ty,Ty) -> Ty -> HsName -> Bool -> [CBind]
mkDataTyCBindL opts sysfEnv (dTy,altTy) ki tyNm isNewtype
  = [ acoreBind1LevTy tyNm metaLevTy (mkSTy ki') (mk st) ]
  where t | isNewtype = snd (snd (tyRecExts2 altTy !! 0) !! 0)
          | otherwise = altTy
        st = SysF.ty2TySysfWithEnv sysfEnv $ ((assocTyLToVarMp $ zip dTyArgVarL dTyArgL) `varUpd`) $ t
        dTyArgL = appUnAppArgs dTy
        dTyArgVarL = map tyVar dTyArgL
        (mk,_) = SysF.tcMergeLamTySeq1AndArgNms ki' (map mkHNm dTyArgVarL)
        ki' = SysF.tyToSysfTyKi sysfEnv ki
%%]

%%[(8 codegen) hs
-- | Make bindings for constructors, given various bits of info
mkDataConCBindL :: EHCOpts -> ToSysfEnv -> CTag -> Ty -> [DataConFldAnnInfo] -> HsName -> Bool -> [CBind]
mkDataConCBindL opts sysfEnv ctag ty annL conNm isNewtype
  | isNewtype
      = [ acoreBind1Ty conNm cty ({- TBD: see TyCore: cast -} acoreExprUnThunk $ acoreVar $ ehcOptBuiltin opts ehbnId)
        ]
  | otherwise
      = [ acoreBind1Ty conNm cty
          $ wrap
          $ acoreLamTy (zip nms $ map mkt $ appUnArrArgs ty)
%%[[(8 coresysf)
          -- $ acoreCast (mkSTy $ appUnArrRes r)
%%]]
          $ foldr (.) id mkStrict
          $ acoreApp tup
          $ map acoreVar nms'
        ]
  where arity | isNewtype = 1
              | otherwise = ctagArity ctag
        nms = (map (\i -> hsnFromString ("x" ++ show i)) [1 .. arity])
        (nms',mkStrict) = (nms, replicate arity id)
        mkt = SysF.ty2TyC opts sysfEnv
%%[[(8 coresysf)
        sysfty = SysF.ty2TySysfWithEnv emptyToSysfEnv ty
        (al,_,_,r) = SysF.tyArrowInstQuArgsRes SysF.ArrowDecompose_InstOnly (tyInstToL ty) 0 sysfty
        cty = mkCTy opts ty sysfty
        wrap = sysftyMkLamWrap emptyCSubst al
        tup  = acoreCast cty (CExpr_Tup ctag)
%%][8
        cty = mkt ty
        wrap = id
        tup  = CExpr_Tup ctag
%%]]
%%]

%%[(8 codegen) hs
-- | Generate all bindings given functions to generate individual bindings.
mkDataBinds
  :: (Bool -> DataGamInfo -> [bind])        -- construct ty bind
     -> (Bool -> DataTagInfo -> [bind])     -- construct val bind
     -> DataGam
     -> ( [bind]                            -- ty bind
        , [bind]                            -- val bind
        )
mkDataBinds mkTy mkCon dataGam
  = ( concat
        [ mkTy (dgiIsNewtype dgi) dgi | dgi <- gamElts dataGam ]
    , concat
        [ concat
            [ mkCon (dgiIsNewtype dgi) dti
            | dti <- Map.elems constrMp
            ]
        | dgi@(DataGamInfo
                { dgiConstrTagMp  = constrMp
                }) <- gamElts dataGam
        ]
    )
%%]

%%[(8 codegen)
SEM Expr
  | Let         loc         .   (dataTyCBindL,dataValCBindL)
                                            =   mkDataBinds
                                                    (
%%[[(8 coresysf)
                                                     if ehcOptCoreSysF @lhs.opts
                                                     then \isNewtype dgi
                                                             -> mkDataTyCBindL @lhs.opts @lhs.sysfEnv (appUn1Arr $ dgiDataTy dgi) (@lhs.finKiVarMp `varUpd` dgiDataKi dgi) (dgiTyNm dgi) isNewtype
                                                     else
%%]]
                                                          \_ _ -> []
                                                    )
                                                    (\isNewtype
                                                      (DataTagInfo
                                                        { dtiConNm      = conNm
                                                        , dtiConFldAnnL = annL
                                                        , dtiCTag       = ctag
                                                        }) -> mkDataConCBindL @lhs.opts @lhs.sysfEnv ctag
                                                                (valGamLookupTyDefault conNm @finValGamDecls)
                                                                annL conNm isNewtype
                                                    )
                                                    @decls.gathDeclDataGam
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Dealing with bang pattern
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR PatExpr [ | | isBang: Bool ]

SEM PatExpr
  | Bang        lhs         .   isBang      =   True
  | * - Bang    lhs         .   isBang      =   False
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Pat for use in case alt
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR PatExpr [ | | cpNm: RPatNm ]

SEM PatExpr
  | Var VarAs AppTop Rec DataFields Con IConst CConst SConst Irrefutable Bang
%%[[97
    Expr
%%]]
                loc         .   cpNm        =   maybe (RPatNmUniq @topNm) RPatNmOrig @mbTopNm
  | App         loc         .   cpNm        =   @arg.cpNm
%%]

%%[(8 codegen)
SEM PatExpr
  | AppTop Con  loc         .   tyConNm     =   tyConNm $ fst $ appUnApp @finKnPatTy -- $ tyAppFunArgsWithLkup (varmpTyLookupCyc2 @lhs.finTyVarMp) @knPatTy
                            .   dgi         =   panicJust ("PatExpr.{AppTop,Con}.dgi: " ++ show @tyConNm)
                                                    $ dataGamLookup @tyConNm $ @lhs.dataGam
                            .   dti         =   panicJust ("PatExpr.{AppTop,Con}.dti: " ++ show @tyConNm ++ "." ++ show @appFunNm)
                                                    $ Map.lookup @appFunNm $ dgiConstrTagMp @dgi
%%]
                            .   dgi         =   ehcOptFromJust @lhs.opts ("PatExpr.{AppTop,Con}.dgi: " ++ show @tyConNm ++ (showPP $ ppParens @finKnPatTy)) emptyDataGamInfo
                                                    $ dataGamLookup @tyConNm $ @lhs.dataGam
                            .   dti         =   ehcOptFromJust @lhs.opts ("PatExpr.{AppTop,Con}.dti: " ++ show @tyConNm ++ "." ++ show @appFunNm) emptyDataTagInfo
                                                    $ Map.lookup @appFunNm $ dgiConstrTagMp @dgi

%%[(8 codegen)
SEM PatExpr
  | AppTop Con  loc         .   tag         =   dtiCTag @dti
                            .   rest        =   CPatRest_Empty
  | Rec         loc         .   tag         =   CTagRec
                            .   rest        =   @recPatExpr.patCRest
  | DataFields  loc         .   tag         =   dtiCTag @dataFieldPatExpr.dti
                            .   rest        =   @dataFieldPatExpr.patCRest
%%]

%%[(8 codegen) hs
fsL2PatOffsetL :: EHCOpts -> FieldSplitL -> AssocL RPatFld (Maybe Int)
fsL2PatOffsetL opts l = [ (RPatFld_Fld n oe n p,Just oi) | (o,(foff,p)) <- zip [0..] l, let (oi,oe) = foffMkOff opts foff o, let n = foffLabel foff ]
%%]

%%[(8 codegen)
SEM PatExpr
  | AppTop      loc         .   rpatBinds   =   fsL2PatOffsetL @lhs.opts $ reverse                 $ @fsRPatL
  | Rec         loc         .   rpatBinds   =   fsL2PatOffsetL @lhs.opts $ rowCanonOrderBy compare $ @fsRPatL
  | DataFields  loc         .   (rpatBindss,rpatBindsNonSat,rpatBind0)
                                            =   let fsL = reverse @fsRPatL
                                                    grp = groupByOn (\o1 o2 -> (foffOffset o1 `compare` foffOffset o2) /= GT) fst
                                                    max = ctagArity @tag - 1
                                                    sat = -- (\v -> v `seq` tr "PatExpr.DataFields.rpatBindss" ("tag" >#< @tag >#< "arity" >#< max) v) $
                                                          listSaturateWith 0 max (foffOffset . fst) $
                                                          -- (\v -> v `seq` tr "PatExpr.DataFields.rpatBindss2" ("tag" >#< @tag >#< "arity" >#< max) v) $
                                                          -- (zipWith (\o n -> (o,(FldKnownOffset n o,RPat_Var (RPatNmOrig n) (acoreTyErr $ "EH.ToCore.PatExpr.DataFields: " ++ show n) False))) [0..max] hsnLclSupply)
                                                            (map (\(n,o) -> (fldInt o, (FldKnownOffset n (fldInt o),RPat_Var (RPatNmOrig n) (acoreTyErr $ "EH.ToCore.PatExpr.DataFields: " ++ show n) False))) (refGen 0 1 $ take (max+1) hsnLclSupply))
                                                in  ( map (fsL2PatOffsetL @lhs.opts . sat) $ grp fsL      -- groups of bindings which can be dealt with simultaneously
                                                    , fsL2PatOffsetL @lhs.opts fsL                        -- bindings
                                                    , fsL2PatOffsetL @lhs.opts $ sat []                   -- 0 binding
                                                    )
%%]

%%[(8 codegen)
ATTR PatExpr [ | | rpat: RPat ]

SEM PatExpr
  | IConst      loc         .   rpat        =   RPat_Int @cpNm @acorety (toInteger @int)
  | CConst      loc         .   rpat        =   RPat_Char @cpNm @acorety @char
  | SConst      loc         .   rpat        =   RPat_Int @cpNm @acorety (-1) -- for now
  | Var         loc         .   rpat        =   RPat_Var @cpNm @acorety False
  | VarAs       loc         .   rpat        =   @patExpr.rpat {rcpPNm = @cpNm}
  | Con         loc         .   rpat        =   RPat_Con @cpNm @acorety @tag (RPatConBind_One CPatRest_Empty [])
  | AppTop      loc         .   rpat        =   RPat_Con @cpNm @acorety @tag (RPatConBind_One @rest (map fst @rpatBinds))
  | Rec         loc         .   rpat        =   case @rest of
                                                    CPatRest_Empty
                                                      ->  RPat_Con @cpNm @acorety @tag (RPatConBind_One @rest (map fst @rpatBinds))
                                                    CPatRest_Var r
                                                      ->  RPat_Con @cpNm @acorety @tag (RPatConBind_One @rest pbL)
                                                          where  pbL = map fst $ fsL2PatOffsetL @lhs.opts $ fsLReorder @lhs.opts $ reverse $ @fsRPatL
  | DataFields  loc         .   rpat        =   RPat_Con @cpNm @acorety @tag
                                                    (rpatConBindUnFlatten (RPatConBind_One @rest $ map fst @rpatBind0)
                                                     $ map (RPatConBind_One @rest . map fst)
                                                           @rpatBindss
                                                    )
  | Irrefutable loc         .   rpat        =   RPat_Irrefutable @cpNm @acorety @patExpr.valCBindL -- $ cbindInPatFlatten @patExpr.cbindInPatL
  | Bang        loc         .   rpat        =   case @patExpr.rpat of
                                                  r@(RPat_Var _ _ _) -> r {rcpMustEval = True}
                                                  r                  -> r
%%]

%%[(97 codegen)
SEM PatExpr
  | Expr        loc         .   rpat        =   RPat_BoolExpr @cpNm (acoreTyErr "EH.ToCore.PatExpr.Expr") @cexpr @mbConst
%%]

%%[(8 codegen)
ATTR AllPatExpr [ | | patCRest: CPatRest ]

SEM RecPatExpr
  | Empty       lhs         .   patCRest    =   CPatRest_Empty
  | Ext         lhs         .   patCRest    =   @recPatExpr.patCRest

SEM DataFieldPatExpr
  | Con         lhs         .   patCRest    =   CPatRest_Empty
  | Ext         lhs         .   patCRest    =   @dataFieldPatExpr.patCRest

SEM PatExpr
  | Var         lhs         .   patCRest    =   CPatRest_Var @nm
  | * - Var     lhs         .   patCRest    =   CPatRest_Empty
%%]

%%[(8 codegen)
ATTR AllPatExpr [ | | fsRPatL: FieldSplitL ]

SEM DataFieldPatExpr
  | Con         lhs         .   fsRPatL     =   []
  | Ext         lhs         .   fsRPatL     =   (FldKnownOffset @nm @ioffset,@patExpr.rpat) : @dataFieldPatExpr.fsRPatL

SEM RecPatExpr
  | Empty       lhs         .   fsRPatL     =   []
  | Ext         lhs         .   fsRPatL     =   (FldComputeOffset @nm @offset,@patExpr.rpat) : @recPatExpr.fsRPatL

SEM PatExpr
  | App         lhs         .   fsRPatL     =   (FldImplicitOffset,@arg.rpat) : @func.fsRPatL
  | AppTop      loc         .   fsRPatL     =   @patExpr.fsRPatL
  | Rec         loc         .   fsRPatL     =   @recPatExpr.fsRPatL
  | DataFields  loc         .   fsRPatL     =   @dataFieldPatExpr.fsRPatL
  | Con         loc         .   fsRPatL     =   []
  | * - App Con Rec
                lhs         .   fsRPatL     =   []
%%]

%%[(8 codegen)
SEM DataFieldPatExpr
  | Ext         loc         .   ioffset     =   fldInt $ dfiOffset $ panicJust "DataFieldPatExpr.Ext.ioffset" $ Map.lookup @nm $ dtiFldMp @dataFieldPatExpr.dti
                            .   offset      =   acoreInt @lhs.opts @ioffset :: CExpr

SEM RecPatExpr
  | Ext         loc         .   ioffset     =   tyRecOffsetWithLkup (varmpTyLookupCyc2 @lhs.finTyVarMp) @nm @recPatExpr.ty
                            .   offset      =   acoreInt @lhs.opts @ioffset :: CExpr
%%]
  | Ext         loc         .   offset      =   acoreInt @lhs.opts (tyRecOffset @nm (@lhs.finTyVarMp `varUpd` @recPatExpr.ty))

%%[(10 codegen)
SEM RecPatExpr
  | Ext         loc         .   offset      :=  cSubstApp @patExpr.cSubst $ acoreNmHolePred @prUid
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Coercions resulting from pred usage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9 codegen)
SEM Expr
  | App AppImpred
                loc         .   appImplsCoeL        =   (acoreCoePoiLApp $ map poPoi @prOccL) ++ [Coe_ImplApp $ ipoId @imPrvOcc]
                            .   appImplsLRCoe       =   lrcoeLFromList @appImplsCoeL
%%]

%%[(12 codegen)
SEM Expr
  | AppImpl     loc         .   appImplsCoeL        =   []
                            .   appImplsLRCoe       =   lrcoeLFromList @appImplsCoeL
%%]

%%[(9 codegen)
SEM Expr
  | Lam
%%[[12
    LamImpl
%%]]
                loc         .   lamBodyCoeL         =   mkLamBodyCoe
                                                            (acoreCoeMap (\e -> rceMatchTy @rceEnv [(@arg.topNm,@acoretyArg)] [RAlt_Alt [@arg.rpat] e Set.empty]))
                                                            @body.appArgCoeL
%%]

%%[(9 codegen)
SEM Expr
  | AppTop Rec Let Lam
                loc         .   poiAndAcoreTyL      =   zipWith (\po ty -> (po,SysF.ty2TyC @lhs.opts @lhs.sysfEnv ty)) @poiL @finKnImplsLExpanded
  | Lam         loc         .   lamArgCoeL          =   acoreCoePoiLLamTy (acoreCoeLetRec @poiBindL) @poiAndAcoreTyL
                                                        ++ [acoreCoeLam1Ty @arg.topNm @acoretyArg]
  | AppTop Rec Let
                loc         .   lamArgCoeL          =   acoreCoePoiLLamTy (acoreCoeLetRec @poiBindL) @poiAndAcoreTyL
%%]

%%[(9 codegen)
SEM Expr
  | *           loc         .   lamArgCoeL          :   {[Coe]}
%%]

%%[(12 codegen)
SEM Expr
  | LamImpl     loc         .   lamArgCoeL          =   [acoreCoeLam1Ty @arg.topNm @acoretyArg `acoreCoeCompose` acoreCoeLetRec @poiBindL]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Gathering coercions/cexpr for app args for optimization by weaving above apptop
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9 codegen)
ATTR Expr [ | | appArgCoeL: {[Coe]}  appFunCExpr: CExpr ]

SEM Expr
  | App AppImpred
%%[[12
    AppImpl
%%]]
                lhs         .   (appArgCoeL,appFunCExpr)
                                                =   if @func.isNewtype
                                                    then ([],@arg.cexpr)
                                                    else (@func.appArgCoeL ++ @appImplsCoeL ++ [acoreCoeApp1 @arg.cexpr],@func.appFunCExpr)
  | AppTop      lhs         .   (appArgCoeL,appFunCExpr)
                                                =   if null @lamArgCoeL
                                                    then (@expr.appArgCoeL,@expr.appFunCExpr)
                                                    else ([],@cexpr)
  | * - App AppImpred AppTop
%%[[12
    AppImpl
%%]]
                lhs         .   appArgCoeL      =   []
                            .   appFunCExpr     =   @cexpr
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Let level bang pattern evaluation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllDecl [ | | bangEvalL USE {++} {[]} : {[CExpr -> CExpr]} ]

SEM Decl
  | Val         lhs         .   bangEvalL       =   if @patExpr.isBang then [acoreLet1StrictTy (hsnUniqify HsNameUniqifier_Strict @patExpr.topNm) @acorety (acoreVar @patExpr.topNm)] else []
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Decl
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR
  AllDecl AllDataConstr
    [ | | tyCBindL
        , valCBindL
        , ffiCBindL
%%[[90
        , ffeCBindL
%%]]
          USE {++} {[]}: CBindL
    ]
%%]

%%[(8 codegen)
SEM Decl
  | TySig       lhs         .   valCBindL       =   []
  | FFI         lhs         .   ffiCBindL       =   let ffi = ffiCoreMk @lhs.opts (\ty -> CExpr_FFI @callconv @safety @impEnt ty) @lUniqFFI @rceEnv @foreignEntInfo @finalTyExpanded
                                                    in  [acoreBind1CatTy CBindCateg_Plain @nm @acorety ffi]
                loc         .   lUniqFFI        :   UNIQUEREF gUniq
  | Val         lhs         .   valCBindL       :=  [ acoreBind1CatTy CBindCateg_Plain @patExpr.topNm @acorety $
%%[[9
                                                      acoreLetMerge True CBindCateg_Rec @chrScopeValBindL $
%%]]
                                                      @expr.cexpr
                                                    ]
                                                    ++ @patExpr.valCBindL -- cbindInPatFlatten @patExpr.cbindInPatL
%%]

%%[(90 codegen)
SEM Decl
  | FFE         loc         .   nmCoerced       =   hsnUniqify HsNameUniqifier_FFECoerced @nm
                            .   (ffeMkCExpr,ffeTy)
                                                =   ffeCoreMk @lhs.opts @lUniqFFE @rceEnv @finalTyExpanded
                            .   ffeCExpr        =   @ffeMkCExpr @expr.cexpr
                loc         .   lUniqFFE        :   UNIQUEREF gUniq
                lhs         .   ffeCBindL       =   [acoreBind1Asp1 @nm (CBound_FFE @callconv @expEnt @ffeCExpr @ffeTy)]
%%]

%%[(93 codegen)
SEM Decl
  | FusionDecl  lhs         .  valCBindL        =   []
  | FusionConv  lhs         .  valCBindL        =   []
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Let bindings + front bindings + body separately
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Front/back bindings are inserted before/after the other bindings, though only on top level.
Meant for global defs like FFI/FFE.
Merging is done to group all mutual recursive stuff together, in particular instances which are out of order declared.
Reordering and splitting up in smaller groups is then done later by a Core transformation.

%%[(8 codegen) hs
mkLetCBodyBindL :: Bool -> CBindCateg -> [(CBindCateg,CBindL)] -> [(CBindCateg,CBindL)] -> [(CBindCateg,CBindL)] -> CExpr -> ([(CBindCateg,CBindL)],CExpr)
mkLetCBodyBindL isStrict howToBind locBindL locOthBindL bodyBindL body
  = if isStrict
    then (locOthBindL,foldr (\(c,b) e -> acoreLet c b e) body (merge $ locBindL ++ bodyBindL))
    else (merge $ locOthBindL ++ locBindL ++ bodyBindL, body)
  where merge (cb1@(c1,b1) : tl)
          = case merge tl of
              (c2,b2) : tl' | c1 == c2 && c1 == CBindCateg_Rec
                  -> (c1,b1++b2) : tl'
              tl' -> cb1 : tl'
        merge [] = []
%%]

%%[(8 codegen)
ATTR
  Expr
    [ | | letValCBindL
        , letTyCBindL
        , frontCBindL
%%[[90
        , backCBindL
%%]]
            : {[(CBindCateg,CBindL)]}
          letCBody: CExpr
    ]

SEM Expr
  | Let         (loc.letCBindRemL,loc.letCBody) =   mkLetCBodyBindL @isStrict @howToBind @letValCBindL @letCBindOtherL @body.letValCBindL @body.letCBody
                lhs         .   letValCBindL    =   @letCBindRemL
                            .   letTyCBindL     =   @letTyCBindL ++ @body.letTyCBindL
                            .   frontCBindL     =   @frontCBindL ++ @body.frontCBindL
%%[[90
                            .   backCBindL      =   @backCBindL ++ @body.backCBindL
%%]]
  | * - Let     lhs         .   letCBody        =   @cexpr
                            .   letValCBindL    =   []
                            .   letTyCBindL     =   []
                            .   frontCBindL     =   []
%%[[90
                            .   backCBindL      =   []
%%]]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Class
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9 codegen) hs
cdictOffset :: HsName -> Ty -> Int
cdictOffset n r = tyRecOffset n $ r
%%]

%%[(9 codegen)
SEM Decl
  | Class       lhs         .   valCBindL   =   let  x = mkHNm "x"
                                                     vx = acoreVar x
                                                     xStrict = hsnUniqifyEval x
                                                     -- vxStrict = acoreVar xStrict :: CExpr
                                                     mkSel n = acoreSatSelsCaseMetaTy
                                                                 ((emptyRCEEnv @lhs.opts) {rceDataGam = @lhs.dataGam}) (Just (xStrict,(acoreTyErr $ "EH.ToCore.Decl.Class.mkSel: " ++ show n))) CMetaVal_Dict vx @dictTag
                                                                 [(n,acoreTyErr $ "EH.ToCore.Decl.Class.mkSel: " ++ show n,{-n,-}cdictOffset n @clsTyRec)] Nothing (acoreVar n)
                                                     mkApp = if ehcCfgInstFldHaveSelf @lhs.opts
                                                             then (\f -> acore1App f vx)
                                                             else id
                                                     dDflt
                                                       = [acoreBind1Ty nDflt (acoreTyErr $ "EH.ToCore.Decl.Class.dDflt: " ++ show nDflt) (acoreLam1Ty nD (acoreTyErr "EH.ToCore.Decl.Class.dDflt") d)] 
                                                       where nDflt = clgiDfltDictNm @clgi2
                                                             d = acoreTagTupTy @dictTag (acoreTyErr "EH.ToCore.Decl.Class.d") (replicate (length $ snd $ tyRecExts $ @clsTyRec) (acoreBuiltinUndefined @lhs.opts))
                                                             nD = hsnUniqify HsNameUniqifier_SelfDict nDflt
                                                in   (maybe dDflt (const []) @mbDefaultInstNm)
                                                     ++ [ acoreBind1CatTy CBindCateg_Plain n
                                                            (SysF.ty2TyC @lhs.opts @lhs.sysfEnv $ tyQuantifyClosed $ [@dataDictTy] `appArr` t)
                                                          $ acoreLam1Ty x (acoreTyErr "EH.ToCore.Decl.Class.valCBindL")
                                                          $ mkApp
                                                          $ mkSel n
                                                        | (n,t) <- @clsFldL
                                                        ]
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Instance
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Three Haskell-constructs give rise to an instance-declaration in EH.
In EH, they can be dicerned by inspecting @instVariant:
* InstNormal:   a normal HS instance-declaration
* InstDefault:  the default definitions of a HS class-declaration
* InstDeriving: a deriving-annotation in a data-declaration
The attribute below generates Core code for these.

As an example we show the processing of a simplified form of a HS class "Eq" 
and "Boolean" as an instance of it:

  class Eq a where
    eq :: a -> a -> Bool
    ne :: a -> a -> Bool
    ne x y = not (eq x y)   -- a default definition
                            -- To show how missing definitions are treated, we do not give a default definition for eq here, as in the Prelude
  instance Eq Boolean where
    eq x y = cond x y (not y)  -- the implementation of equality on booleans
                               -- For the "ne" function, it falls back on the default implementation

In the transformation below, before the actual Core code is generated, we have two auxiliary functions:
  * mkNormalD:  generates the dictionary for an instance definition (either from code supplied by the HS programmer, or generated because of "deriving")
  * mkDefaultD: generates the dictionary for a default definition
Also there are some local values:
  * some fresh variable names to be used in the Core code
  * some auxiliary lists, which hold transformations of the original member definitions
Some of these local values are local to mkNormalD or mkDefaultD, others can be definied generically for both.

The elements of the lists correspond to class members. The correspondence can be encode in two ways:
  * as an association list (either 2-tuples, or CBinds)
  * positional: a fixed number of elements in a fixed order
We explain their meaning by showing example values during processing of the Eq code mentioned above.
Part of the processing is generating fresh names for members.
In the example, "03" is a prefix specific for the default definitions of class Eq, and "05" for the instance definition Eq Boolean.

We use a few notational conventions in the example:
 * what is shown as a string is really an HsName, thus "eq" really is HsName_Base "eq"
 * we use => to denote a CBind, thus  a=>b  means  CBind a m b 
 * we omit the meta-annotation m in CBinds.

 
memberNames          =  [       "eq",       "ne" ]  positional
memberNewNames       =  [     "03eq",     "03ne" ]  positional
      or, respectively, [     "05eq",     "05ne" ]  positional
memberNewVars        =  [ Var "03eq", Var "03ne" ]  positional
      or, respectively, [ Var "05eq", Var "05ne" ]  positional

defaultBindings      =  [                                               "ne"   => \xy.not(eq x y) ]  association
defaultBindingPairs  =  [                                              ("ne"   ,  \xy.not(eq x y))]  association
defaultMbBodies      =  [ Nothing                                , Just           \xy.not(eq x y) ]  positional
defaultMbNewNames    =  [ Nothing                                , Just "03ne"                    ]  positional
defaultBodies        =  [                   cundef               ,                \xy.not(eq x y) ]  positional
defaultNewBindings   =  [         "03eq" => cundef               ,      "03ne" => \xy.not(eq x y) ]  association, and also positional

instanceBindings     =  [         "eq" =>   \xy.cond x y (not y)                                  ]  association
instanceBindingPairs =  [        ("eq" ,    \xy.cond x y (not y))                                 ]  association
instanceMbBodies     =  [ Just              \xy.cond x y (not y) , Nothing                        ]  positional
instanceMbNewNames   =  [ Just    "05eq"                         , Nothing                        ]  positional
instanceMbNames      =  [ Just    "eq"                           , Nothing                        ]  positional
instanceNameMapping  =  [        ("eq"  ,   Var "05eq")                                           ]  association
instanceNewBindings  =  [         "05eq" => \xy.cond x y (not y)                                  ]  association


The primary use of these lists is generating the ...NewBindings.
But for the meta-annotation, also the ...MbNewNames lists are needed.
The other lists are auxiliary.

%%[(9 codegen) hs
-- | Make the various names required for instance building
mkInstanceNames
  :: EHCOpts
     -> ToSysfEnv
     -> HsName
     -> Ty
     -> ( AssocL HsName (Ty,CTy)
        , [HsName]
        , [HsName]
        , [CExpr]
        )
mkInstanceNames
     opts sysfEnv dictNm instanceRecTy
  = ([(n,(t,SysF.ty2TyC opts sysfEnv t)) | (n,t) <- instanceFieldL],memberNames,memberNewNames,memberNewVars)
  where instanceFieldL  = rowCanonOrder $ snd $ tyRecExts instanceRecTy
        memberNames     = assocLKeys instanceFieldL
        memberNewNames  = [ hsnUniqifyStr HsNameUniqifier_DictField (show n) dictNm | n <- memberNames ]
        memberNewVars   = map acoreVar memberNewNames
%%]

%%[(9 codegen) hs
-- | Make a dictionary corresponding to an instance declaration
mkNormalInstance
  :: EHCOpts
     -> ToSysfEnv                           -- environmental info for SysF stuff
     -> ClGamInfo                           -- info about the class
     -> DataGam                             -- env/gamma for datas
     -> CTag                                -- tag of the dictionary (as data type)
     -> (HsName,HsName,HsName)              -- various names for the dictionary under construction at various stages of construction, also used externally
     -> CTy                                 -- instance dict as data type
     -> Ty                                  -- instance dict as record
     -> ( [HsName]                          -- names of super class fields
        , [HsName]                          -- names of super class dicts, given as arg
        , [HsName]                          -- names of context class dicts, given as arg
        )
     -> [CBind]                             -- bindings for decls of the instance
     -> ([CBind]                            -- bindings for decls related context reduction, both Assume & Prove
        ,[CBind]                            -- bindings for super class related context reduction, only Prove
        ,[CBind]                            -- bindings for super + ctxt class related context reduction, only Assume
        )
     -> ( CExpr                             -- the instance
        , CMetaVal                          -- the meta info about the instance
        )
mkNormalInstance
      opts sysfEnv clgi dataGam dictTag
      (dictNm,_,dictBuildNm)
      instanceTy instanceRecTy
      (superFldNmL,superNmL,contextNmL)
      declsCBindL
      (chrDeclsCBindL,chrSuperProveCBindL,chrSuperCtxtAssumeCBindL)
  = ( bind4
    , CMetaVal_DictInstance (TrackVarApply (ctagTyNm dictTag) [] : TrackVarApply dfltNm [] : instanceAndSuperTracks )
    )
  where dfltNm       = clgiDfltDictNm clgi
        rsltNm       = dictBuildNm
        rsltNmStrict = hsnUniqifyEval rsltNm
        dfltNmStrict = hsnUniqifyEval dfltNm

        dfltVar      = acoreVar dfltNm
        rsltVar      = acoreVar rsltNm
        rsltVarStrict= acoreVar rsltNmStrict
        dfltVarStrict= acoreVar dfltNmStrict

        (instanceFieldL,memberNames,memberNewNames,memberNewVars) 
                            = mkInstanceNames opts sysfEnv dictNm instanceRecTy
        mkSetFlds           = mkInstanceSetFlds opts dataGam dictTag instanceFieldL instanceRecTy
        
        
        -- mkCTy = SysF.ty2TyC opts sysfEnv

        instanceBindingPairs= [ (nm,v)
                              | CBind_Bind nm asps <- declsCBindL, CBound_Bind _ v <- asps
                              ]
        instanceMbBodies    = map (flip lookup instanceBindingPairs) memberNames
        instanceMbNewNames  = let f _ Nothing  = Nothing
                                  f n (Just e) = Just n
                              in zipWith f memberNewNames instanceMbBodies
        instanceMbNames     = let f _ Nothing  = Nothing
                                  f n (Just _) = Just n
                              in zipWith f memberNames instanceMbNewNames
        instanceNameMapping = [ (nm, CMetaVal_Val, v)
                              | (Just nm,v) <- zip instanceMbNames memberNewVars
                              ]
        instanceNewBindings = [ acoreBind1MetaTy nm CMetaVal_Val (acoreTyErr $ "EH.ToCore.mkNormalInstance.instanceNewBindings: " ++ show nm) v
                              | (nm,Just v) <- zip memberNewNames instanceMbBodies
                              ]
                              
        superNewVars        = map acoreVar superNmL
        superNameMapping    = zip3 superFldNmL
                                   (repeat CMetaVal_Dict)
                                   superNewVars

        superNameMapping2   = zip superFldNmL
                                  superNmL
        superPairs          = map getBindLeftAndRightVar chrSuperProveCBindL
        
        doubleLookup :: HsName -> Maybe HsName
        doubleLookup nm   =  do { nm2 <- lookup nm superNameMapping2
                                -- ; nm3 <- lookup nm2 superPairs
                                ; return nm2 -- nm3
                                }
        
        superMbNewNames   =  map doubleLookup memberNames

        instanceAndSuperMbNewNames = let f (Just x) _ = Just x
                                         f _ (Just y) = Just y
                                         f _ _        = Nothing
                                     in zipWith f instanceMbNewNames superMbNewNames

        instanceAndSuperTracks = map mbNameToTrack instanceAndSuperMbNewNames

        instanceCHRBindings = chrSuperCtxtAssumeCBindL ++ chrSuperProveCBindL ++ chrDeclsCBindL

        dict1     = acore1App dfltVar rsltVar
        bind1     = acoreBind1MetaTy dfltNmStrict CMetaVal_Dict instanceTy dict1
        
        dict2     = acoreLetBase (acoreBindcategStrict) [bind1] (mkSetFlds (superNameMapping ++ instanceNameMapping) dfltVarStrict)
        bind2     = acoreBind1MetaTy rsltNmStrict (CMetaVal_Track TrackSelf) instanceTy dict2
                             
        dict3     = acoreLetBase (acoreBindcategPlain) [bind2] rsltVarStrict
        bind3     = acoreBind1MetaTy rsltNm       (CMetaVal_Track TrackSelf) instanceTy dict3

        dict4     = acoreLetRec ([bind3] ++ instanceNewBindings ++ instanceCHRBindings) rsltVar
        bind4     = acoreLamTy (acoreTyErrLift "EH.ToCore.mkNormalInstance.dict4" contextArguments) dict4        

        -- The above generates the following Core code as dict4:
        --
        -- letrec reslt = let rsltStrict = let! dfltStrict = dflt rslt
        --                                 in   case defltStrict of
        --                                        (Dict-C _1 _2 _3 _4) -> (Dict-C _1 inst2 _3 inst4)     -- in this example, field 2 and 4 are defined in the isntance, 1 and 3 are taken from the defaultdefinitions
        --                in  rsltStrict
        --        inst2 = ...
        --        inst4 = ...
        -- in reslt

        contextArguments = contextNmL
%%]

%%[(9 codegen) hs
--  Make a dictionary for a normal instance, the default-definitions of a class, or for a derived instance
mkInstanceCBindL
  :: EHCOpts
     -> ToSysfEnv                           -- environmental info for SysF stuff
     -> ClGamInfo                           -- info about the class
     -> TyKiGam                             -- env/gamma for ki of ty's
     -> DataGam                             -- env/gamma for datas
     -> InstVariant                         -- what kind of instance
     -> CTag                                -- tag of the dictionary (as data type)
     -> (HsName,HsName,HsName)              -- various names for the dictionary under construction at various stages of construction, also used externally
     -> Ty                                  -- instance dict as data type
     -> Ty                                  -- instance dict as record
     -> ( [HsName]                          -- names of super class fields
        , [HsName]                          -- names of super class dicts, given as arg
        , [HsName]                          -- names of context class dicts, given as arg
        )
     -> [CBind]                             -- bindings for decls of the instance
     -> ([CBind]                            -- bindings for decls related context reduction, both Assume & Prove
        ,[CBind]                            -- bindings for super class related context reduction, only Prove
        ,[CBind]                            -- bindings for super + ctxt class related context reduction, only Assume
        )
     -> [CBind]
mkInstanceCBindL
      opts sysfEnv clgi tyKiGam dataGam instVariant dictTag
      nms@(dictNm,dictSelfNm,dictBuildNm)
      instanceTy
      instanceRecTy
      nmLs@(superFldNmL,superNmL,contextNmL)
      declsCBindL
      chrBindLs@(chrDeclsCBindL,chrSuperProveCBindL,chrSuperCtxtAssumeCBindL)
  = [acoreBind1MetaTy dictNm generatedMeta instanceCTy generatedDictionary]
  where (generatedDictionary, generatedMeta)
          = case instVariant of
               InstNormal     -> mkNormalD  declsCBindL
               InstDefault    -> mkDefaultD declsCBindL
%%[[91               
               InstDeriving _ -> mkNormalD  declsCBindL
%%]]
        rsltNm   = dictBuildNm
        rsltVar  = acoreVar rsltNm
        
        instanceCTy = SysF.ty2TyC opts sysfEnv instanceTy
                                                                                                                                          
        mkNormalD instanceBindings
          = mkNormalInstance
              opts sysfEnv clgi dataGam dictTag nms instanceCTy instanceRecTy nmLs
              instanceBindings chrBindLs

        -- Make a dictionary corresponding to (the default definitions in a) class definition
        mkDefaultD defaultBindings
          = let selfNm    = dictSelfNm
          
                (instanceFieldL,memberNames,memberNewNames,memberNewVars) 
                                    = mkInstanceNames opts sysfEnv dictNm instanceRecTy

                lookupMeta n = if n `elem` superFldNmL then CMetaVal_Dict else CMetaVal_Val
          
                defaultBindingPairs = [ (nm,v)
                                      | CBind_Bind nm asps <- defaultBindings, CBound_Bind _ v <- asps
                                      ]
                defaultMbBodies     = map (flip lookup defaultBindingPairs) memberNames
                defaultMetas        = map lookupMeta                        memberNames
                defaultBodies       = map (maybe (acoreBuiltinUndefined opts) id) defaultMbBodies
                defaultMbNewNames   = let f _ Nothing  = Nothing
                                          f n (Just _) = Just n
                                      in zipWith f memberNewNames defaultMbBodies
                defaultTracks       = map mbNameToTrack defaultMbNewNames
                
                defaultNewBindings  = zipWith3 (\n m b -> acoreBind1MetaTy n m (acoreTyErr $ "EH.ToCore.mkInstanceCBindL.defaultNewBindings: " ++ show n) b)
                                                                memberNewNames 
                                                                defaultMetas
                                                                defaultBodies
                defaultCHRBindings  = chrDeclsCBindL 
                                                   
                dict5     = acoreTagTupTy dictTag (acoreTyErr "EH.ToCore.mkInstanceCBindL.dict5") memberNewVars -- acoreApp (CExpr_Tup dictTag) memberNewVars
                bind5     = acoreBind1MetaTy rsltNm CMetaVal_Dict (acoreTyErr $ "EH.ToCore.mkInstanceCBindL.bind5: " ++ show rsltNm) dict5

                dict6     = acoreLetRec ([bind5] ++ defaultNewBindings ++ defaultCHRBindings) rsltVar
                bind6     = acoreLam1Ty selfNm (acoreTyErr $ "EH.ToCore.mkInstanceCBindL.bind6: " ++ show selfNm) dict6

            in  ( bind6
                , CMetaVal_DictClass defaultTracks
                )
%%]

An auxiliary function that decides (based on an option) how
to set fields in a dictionary:
- by updates of a record
- by matching and rebuilding a datatype 

%%[(9 codegen) hs
mkInstanceSetFlds :: EHCOpts -> DataGam -> CTag -> AssocL HsName (Ty,CTy) -> Ty -> [(HsName,CMetaVal,CExpr)] -> CExpr -> CExpr
mkInstanceSetFlds opts dataGam dictTag instanceFieldL instanceRecTy
  = if   ehcCfgClassViaRec opts 
    then mkSetFldsRec  
    else mkSetFldsData
  where off n = cdictOffset n instanceRecTy
        off' n = tyExtsOffset n instanceFieldL
        mkSetFldsRec ts d0
          = foldl (\d (n,_,v) -> mkSet d n v) d0 ts
          where mkSet d n v = CExpr_TupUpd d dictTag n (acoreInt opts $ off n) v

        mkSetFldsData ts d0
          = acoreSatSelsCaseMetaTy env Nothing CMetaVal_Dict d0 dictTag nmLblOffL Nothing sel
          where env = (emptyRCEEnv opts) {rceDataGam = dataGam}
                fullListWithTrivialValues = [ (o, (o, t, acoreVar n)) 
                                            | (n,t,o) <- nmLblOffL 
                                            ]
                sparseListWithInterestingValues = [ (o, maybe (acoreTyErr $ "mkInstanceSetFlds.sparseListWithInterestingValues: " ++ show n) snd mbt, v) 
                                                  | (n,m,v) <- ts, let ((o,_),mbt) = off' n
                                                  ]
                arity = ctagArity dictTag
                ns = take arity hsnLclSupply
                nmLblOffL :: [(HsName,CTy,Int)]
                nmLblOffL = zipWith3 (\n (_,(_,t)) o -> (n,t,o)) ns instanceFieldL [0..]
                sel = acoreTagTupTy dictTag (acoreTyErr "mkInstanceSetFlds.sel") -- acoreApp       (CExpr_Tup dictTag) 
                                     (map (\(_,_,v) -> v)
                                      $ listSaturateWith 0 
                                                         (arity-1) 
                                                         (\(o,_,_) -> o)
                                                         fullListWithTrivialValues
                                                         sparseListWithInterestingValues
                                     )
%%]

%%[(9 codegen)
SEM Decl
  | Instance    (lhs.valCBindL,loc.cSubstInst)=   let (bindL,cSubstInstL) = 
                                                           case @instVariant of
                                                             InstNormal   -> (@decls.valCBindL,[])
                                                             InstDefault  -> (@decls.valCBindL,[])
%%[[91               
                                                             InstDeriving _
%%[[92
                                                               | not $ null @generForFitsInL
                                                                          -> unzip
                                                                               [ (acoreBind1 fld $ acore1App f $ acoreBuiltinUndefined @lhs.opts,s)
                                                                               | ((fld,dflt,_,_),fo,u) <- zip3 @generForFitsInL @foGenerDerivL (mkNewLevUIDL (length @generForFitsInL) @lUniq_bind)
                                                                               , let (f,s) = foAppLRCoeAsSubst @lhs.opts u fo @lhs.finTyVarMp @cSubstDecls (acoreVar dflt)
                                                                               ]
                                                               | otherwise
%%]]
                                                                          -> ([ @mkf dcf | dcf <- dclFldL @derivDCL ],[])
%%]]
                                                  in  ( mkInstanceCBindL
                                                        @lhs.opts @lhs.sysfEnv @clgi @lhs.finTyKiGam @lhs.dataGam @instVariant @dictTag
                                                        (@dictNm,@dictSelfNm,@dictBuildNm)
                                                        @finalTy @recTy
                                                        (@supClsFldNmL,@chrSuperProveNmL,@chrCtxtArgNmL)
                                                        bindL
                                                        ( @chrAssumeDeclsInstBindL ++ @chrScopeDeclsBindL
                                                        , @chrScopeSuperBindL
                                                        , @chrAssumeSuperBindL ++ @chrAssumeDeclsCtxtBindL
                                                        )
                                                      , foldr cSubstApp emptyCSubst cSubstInstL
                                                      )
%%[[92
                loc         .   lUniq_bind  :   UNIQUEREF gUniq
%%]]
  | InstanceIntro
                lhs         .   valCBindL   =   [acoreBind1MetaTy @dictNm CMetaVal_Dict (acoreTyErr $ "EH.ToCore.Decl.InstanceIntro.valCBindL: " ++ show @dictNm) @expr.cexpr]
%%]
                                                                             -- , let (e,s) = mkWeaveExpr -- :: EHCOpts -> UID -> VarMp -> CSubst -> (CExpr->CExpr) -> CExpr -> [Coe] -> [Coe] -> (CExpr,CSubst)
                                                                             --                   @lhs.opts u @lhs.finTyVarMp @cSubstDecls
                                                                             --                   (flip acore1App $ acoreBuiltinUndefined @lhs.opts) (acoreVar dflt)
                                                                             --                   [] []

%%[(9 codegen) hs
getBindRightVar :: CBind -> Maybe HsName

getBindRightVar (CBind_Bind _ [CBound_Bind _ v]) = acoreExprMbVar v
getBindRightVar _ = Nothing


getBindLeftAndRightVar :: CBind -> (HsName,HsName)

getBindLeftAndRightVar (CBind_Bind nm1 [CBound_Bind _ (CExpr_Var ref2)]) = (nm1, acbrefNm ref2)
getBindLeftAndRightVar _ = error "getBindLeftAndRightVar: not a bind"

mbNameToTrack Nothing   = TrackNone
mbNameToTrack (Just nm) = TrackVarApply nm []

%%]

An auxiliary function that generates the bindings for a DERIVED instance

%%[(91 codegen) hs
mkInstanceDerivingFldBind :: EHCOpts -> RCEEnv -> DataGam -> UID -> DataGamInfo -> Ty -> HsName -> CTag -> [[PredOcc]] -> [PredOcc] -> DerivClsFld -> CBind
mkInstanceDerivingFldBind opts rceEnv dataGam uniq derivDataDGI derivHdDataTy dictBuildNm ctag derivAltsPrOcc derivExtraPrOcc
  = mkf
  where rsltNm   = dictBuildNm
        rsltVar  = acoreVar rsltNm
        
        mkf :: DerivClsFld -> CBind
        mkf dcf
         = acoreBind1Ty (dcfNm dcf) (acoreTyErr $ "EH.ToCore.mkInstanceDerivingFldBind.mkf.dcfNm: " ++ show (dcfNm dcf))
             (if fArity == 0
              then acoreLamTy (acoreTyErrLift "EH.ToCore.mkInstanceDerivingFldBind.mkf.A" $ dcfInitialArgL dcf)
                   $ dcfNoArgSubsCExpr dcf rceEnv
                       [ (dti,mkcSubs dti (repeat []) altPrOccL) | (dti,altPrOccL) <- zip dtis derivAltsPrOcc ]
                       nrOfAlts rsltVar extraCxL (dcfInitialArgL dcf)
              else acoreLamTy (acoreTyErrLift "EH.ToCore.mkInstanceDerivingFldBind.mkf.B" $ dcfInitialArgL dcf ++ take fArity nsA)
                     (dcfWrapCase dcf opts derivDataDGI nrOfAlts n1 (dcfInitialArgL dcf)
                      $ acoreStrictSatCaseTy rceEnv (Just (hsnUniqifyEval n1,(acoreTyErr $ "EH.ToCore.mkInstanceDerivingFldBind.mkf.n1: " ++ show n1))) n1v
                        [ CAlt_Alt (dcfMkCPat dcf altInx ctag (ctagArity ctag) (Just $ n1subs ctag))
                                   (mkc splDTI altInx (fArity - 1) n1s [n1subs ctag] altPrOccL)
                        | (ctag,altPrOccL) <- zip (map dtiCTag dtis) derivAltsPrOcc
                        , let splDTI@(dtisLT,_,_) = splitDTIs ctag dtis
                              altInx = length dtisLT
                        ]
             )       )
         where n1v = acoreVar n1
               nsA@(n1:n1s) = hsnLclSupplyWith (mkHNm "x")
               dtis  = panicJust "Decl.Instance.Deriving.dataGamDTIsOfTy" $ dataGamDTIsOfTy derivHdDataTy dataGam
               nrOfAlts = length dtis
               splitDTIs t ts -- in (lt,eq,gt), according to list ordering
                 = (l,e,g)
                 where (l,(e:g)) = span ((/= t) . dtiCTag) ts
               fArity = (length $ appUnArrArgs $ dcfTy dcf) - dcfNrOmitTailArg dcf - length (dcfInitialArgL dcf) - 1 {- dictionary -}
               n1subs t = nsubs t n1
               nsubs t n = take (ctagArity t) $ hsnLclSupplyWith n
               extraCxL = [ acoreNmHolePred (poPoi prOcc) | prOcc <- derivExtraPrOcc ]
               mkcSubs dti nmFldLL altPrOccL
                 = [ acoreApp
                       (acoreVar (dcfNm dcf))
                       ([acoreNmHolePred (poPoi prOcc)]
                         ++ (dcfInitialSubArgL dcf dti ++ map acoreVar nmFldL))
                   | (nmFldL,prOcc) <- zip nmFldLL altPrOccL
                   ]
               mkc tg@(dtisLT,dti,dtisGT) altInx arity nms nmFldLL altPrOccL
                 = case nms of
                     (n:ns) | arity > 0
                       -> acoreStrictSatCaseTy rceEnv (Just (hsnUniqifyEval n,(acoreTyErr $ "EH.ToCore.mkInstanceDerivingFldBind.mkf.mkc.n: " ++ show n))) (acoreVar n)
                            (   [ mka (dtiCTag dti) tsubs (mkc tg altInx (arity - 1) ns (nmFldLL ++ [tsubs]) altPrOccL) ]
                             ++ [ mka t (nsubs t n) (dcfAllTagLtCExpr dcf) | t <- map dtiCTag dtisLT ]
                             ++ [ mka t (nsubs t n) (dcfAllTagGtCExpr dcf) | t <- map dtiCTag dtisGT ]
                            )
                       where tsubs = nsubs (dtiCTag dti) n
                             mka ctag nsubs e = CAlt_Alt (dcfMkCPat dcf altInx ctag (ctagArity ctag) (Just nsubs)) e
                     _ -> dcfFoldSubsCExpr dcf uniq rceEnv dti (altInx, nrOfAlts) (dcfInitialArgL dcf)
                          $ mkcSubs dti (transpose nmFldLL) altPrOccL
%%]

%%[(91 codegen)
SEM Decl
  | Instance    loc         .   mkf         =   mkInstanceDerivingFldBind @lhs.opts @rceEnv @lhs.dataGam @lUniq @derivDataDGI @derivHdDataTy @dictBuildNm @dictTag @derivAltsPrOcc @derivExtraPrOcc
%%]

%%[(92 codegen) hs
mkDataGenerBinds
  :: -- (AbstractCore e m b bcat mbind t) =>
        EHCOpts
     -> ToSysfEnv
     -> RCEEnv
     -> ClGam                               -- env/gamma for class
     -> TyKiGam                             -- env/gamma for ki of ty's
     -> DataGam                             -- env/gamma for datas
     -> UID                                 -- uniq
     -> [GenerDataInstInfo]                 -- inst infos
     -> ([CBind],[Err])
mkDataGenerBinds
     opts sysfEnv rceEnv clGam tyKiGam dataGam
     uniq instInfoL
  = (concat instBinds, concat errs)
  where (instBinds,errs) = unzip $ map mk instInfoL
        mk (orignm,dictNm,clNm,instKind,pr)
          = ( mkInstanceCBindL opts sysfEnv clgi tyKiGam dataGam InstNormal (clgiDictTag clgi) (dictNm,dictSelfNm,dictBuildNm) (pred2DataTy pr) recTy ([],[],[])
                               binds ([],[],[])
            , foErrL evFO
            )
          where (_,u1,u2) = mkNewLevUID2 uniq
                clgi  = panicJust ("mkDataGenerBinds.clGam: " ++ show dictNm ++ ": " ++ show clNm) $ gamLookup clNm clGam
                
                -- derived names required for building
                (dictSelfNm,dictBuildNm) = mkInstanceBuildNms dictNm
                
                -- match predicate to get the record type describing fields of dictionary
                evFO  = fitPredToEvid' u1 emptyVarMp (mkTyPr pr) (Left clgi)
                recTy = foVarMp evFO `varUpd` foTy evFO
                
                -- the bindings for datatypes acting as labels
                binds = case instKind of
                          GenerInstKind_Representable remArity proj
                            -> [ acoreBind1 (ehcOptBuiltin2 opts ehbnGenerClassRepresentableNFldFrom remArity) (projFrom opts rceEnv proj)
                               , acoreBind1 (ehcOptBuiltin2 opts ehbnGenerClassRepresentableNFldTo   remArity) (projTo   opts rceEnv proj)
                               ]

                          GenerInstKind_Datatype
                            -> [ mkBindStr ehbnGenerClassDatatypeFldName                         $ hsnQualified orignm
                               , mkBindStr ehbnGenerClassDatatypeFldModule $ maybe hsnUnknown id $ hsnQualifier orignm
                               ]

                          GenerInstKind_Selector
                            -> [ mkBindStr ehbnGenerClassSelectorFldName                         $ hsnQualified orignm
                               ]

                          GenerInstKind_Constructor tyNm
                            -> [ mkBindStr ehbnGenerClassConstructorFldName $ hsnQualified orignm ]
                               ++ (if Map.null (dtiFldMp dti) then [] else [mkBind ehbnGenerClassConstructorFldIsRec $ acoreVar $ biNm ehbnBoolTrue])
                               ++ (if isNothing mbInfix
                                   then []
                                   else [mkBind ehbnGenerClassConstructorFldFixity
                                         $ acoreApp (acoreVar $ biNm ehbnGenerDataFixityAltInfix)
                                         $ [ acoreVar (biNm (case fixity of
                                                               Fixity_Infix  -> ehbnGenerDataAssociativityAltNot
                                                               Fixity_Infixr -> ehbnGenerDataAssociativityAltRight
                                                               Fixity_Infixl -> ehbnGenerDataAssociativityAltLeft
                                                      )     )
                                           , acoreInt opts prio
                                           ]
                                        ]
                                  )
                            where dgi = panicJust ("mkDataGenerBinds.dataGam: " ++ show tyNm) $ dataGamLookup tyNm dataGam
                                  dti = panicJust ("mkDataGenerBinds.dgiConstrTagMp: " ++ show orignm) $ Map.lookup orignm $ dgiConstrTagMp dgi
                                  mbInfix@(~(Just (prio,fixity))) = dtiMbFixityPrio dti

                          -- _ -> []

        -- get a builtin name
        biNm          = ehcOptBuiltin opts
        
        -- utils for bindings
        argNm         = mkHNm "x"
        mkBindx a f x = acoreBind1 (biNm f) (acoreLamTy (acoreTyErrLift "mkDataGenerBinds.mkBindx" [a]) x)
        mkBind        = mkBindx argNm
        mkBindStr f n = mkBind f $ acoreBuiltinString opts $ show n
%%]

%%[(92 codegen)
SEM Expr
  | Let         loc         .   (cDataGenerBindL,errsDataGenerBind)
                                            =   mkDataGenerBinds
                                                    @lhs.opts @sysfEnv
                                                    (@rceEnv {rceValGam = @finValGam `gamUnion` rceValGam @rceEnv})
                                                    @forDeclsClGam @lhs.finTyKiGam @lhs.dataGam
                                                    @lUniq_gener @generInstInfoL
                loc         .   lUniq_gener :   UNIQUEREF gUniq
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Case
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
%%]
ATTR AllCase [ | | mkAlts: MkAlts ]

SEM CaseAlt
  | Pat         lhs         .   mkAlts      =   \n -> [@patExpr.mkAlt n @expr.cexpr]

SEM CaseAlts
  | Nil         lhs         .   mkAlts      =   \n -> []
  | Cons        lhs         .   mkAlts      =   \n -> @hd.mkAlts n ++ @tl.mkAlts n

%%[(8 codegen)
ATTR CaseAlt [ | | ralt: RAlt  ralt': RAlt ]
ATTR CaseAlts [ | | raltL: {[RAlt]}  raltL': {[RAlt]} ]

SEM CaseAlt
  | Pat         lhs         .   ralt        =   RAlt_Alt [@patExpr.rpat] @expr.cexpr @expr.caseFailS
                            .   ralt'       =   RAlt_Alt (fsL2PatL $ reverse @patExpr.fsRPatL) @expr.cexpr @expr.caseFailS

SEM CaseAlts
  | Nil         lhs         .   raltL       =   []
                            .   raltL'      =   []
  | Cons        lhs         .   raltL       =   @hd.ralt  : @tl.raltL
                            .   raltL'      =   @hd.ralt' : @tl.raltL'
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Pat for use in (recursive) let bindings (lazy unpacking)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllPatExpr [ | | valCBindL USE {++} {[]}: CBindL ]

SEM PatExpr
  | AppTop Rec  loc         .   valCBindL   =   acoreRPatBindL2BindL @rceEnv (not $ null @valCBindLSub) @lhs.ceParentNm @tag (Just (@rest,length @fsRPatL)) @rpatBinds 
  | DataFields  loc         .   valCBindL   =   acoreRPatBindL2BindL @rceEnv (not $ null @valCBindLSub) @lhs.ceParentNm @tag (Just (@rest,ctagArity @tag)) @rpatBindsNonSat 
  | AppTop Rec DataFields
                lhs         .   valCBindL   =   @valCBindL ++ @valCBindLSub
%%]

%%[(8 codegen)
SEM PatExpr
  | AppTop      loc         .   valCBindLSub=   @patExpr.valCBindL
  | Rec         loc         .   valCBindLSub=   @recPatExpr.valCBindL
  | DataFields  loc         .   valCBindLSub=   @dataFieldPatExpr.valCBindL
%%]

%%[(8 codegen)
ATTR AllPatExpr [ ceParentNm: HsName | | ]

SEM PatExpr
  | App         arg         .   ceParentNm  =   rpatNmNm @arg.cpNm

SEM RecPatExpr
  | Ext         patExpr     .   ceParentNm  =   rpatNmNm @patExpr.cpNm

SEM Decl
  | Val         patExpr     .   ceParentNm  =   @patExpr.topNm

SEM CaseAlt
  | Pat         patExpr     .   ceParentNm  =   @patExpr.topNm

SEM Expr
  | Lam         arg         .   ceParentNm  =   @arg.topNm
%%]

%%[(12 codegen)
SEM Expr
  | LamImpl     arg         .   ceParentNm  =   @arg.topNm
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Can a CExpr fail, that is, has a guard which can fail? Indicated by non-emptyness of caseId's
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR Expr [ | | caseFailS USE {`Set.union`} {Set.empty}: UIDS ]

SEM Expr
  | Case        lhs         .   caseFailS   =   @caseFailS
%%]
  | CaseAltFail lhs         .   caseFailS   =   Set.singleton @caseId

